/*
 * Copyright (c) 2014 - Qeo LLC
 *
 * The source code form of this Qeo Open Source Project component is subject
 * to the terms of the Clear BSD license.
 *
 * You can redistribute it and/or modify it under the terms of the Clear BSD
 * License (http://directory.fsf.org/wiki/License:ClearBSD). See LICENSE file
 * for more details.
 *
 * The Qeo Open Source Project also includes third party Open Source Software.
 * See LICENSE file for more details.
 */

#include <stdio.h>
#include <ctype.h>
#include "dds/dds_aux.h"
#include "dds/dds_debug.h"
#include "pid.h"

const char	*progname;
int		trace = 0;
int		verbose = 0;
int		no_rtps = 0;
int		shell = 0;
unsigned	domain_id = 0;
unsigned	delay_ms = 1000;

/* usage -- Print out program usage. */

void usage (void)
{
	fprintf (stderr, "%s -- test program for the PID API.\r\n", progname);
	fprintf (stderr, "Usage: %s [switches] {<testname>}\r\n", progname);
	fprintf (stderr, "\r\n");
	fprintf (stderr, "Switches:\r\n");
	fprintf (stderr, "   -i <num>   Domain id to use.\r\n");
	fprintf (stderr, "   -r         No lower layer RTPS functionality.\r\n");
#ifdef DDS_DEBUG
	fprintf (stderr, "   -s         Enable Debug shell.\r\n");
#endif
	fprintf (stderr, "   -v         Verbose: log overall functionality.\r\n");
	fprintf (stderr, "   -vv        Very verbose logging.\r\n");
	fprintf (stderr, "   -h         Display help info.\r\n");
	exit (1);
}

/* get_num -- Get a number from the command line arguments. */

int get_num (const char **cpp, unsigned *num, unsigned min, unsigned max)
{
	const char	*cp = *cpp;

	while (isspace ((unsigned char) *cp))
		cp++;
	if (*cp < '0' || *cp > '9')
		return (0);

	*num = (unsigned) atoi (cp);
	if (*num < min || *num > max)
		return (0);

	while (*cp)
		cp++;

	*cpp = cp;
	return (1);
}

#define	INC_ARG()	if (!*cp) { i++; cp = argv [i]; }

/* do_switches -- Command line switch decoder. */

int do_switches (int argc, const char **argv)
{
	int		i, help;
	const char	*cp;

	progname = argv [0];
	help = 0;
	for (i = 1; i < argc; i++) {
		cp = argv [i];
		if (*cp++ != '-')
			break;

		while (*cp) {
			switch (*cp++) {
				case 'i':
					INC_ARG ()
					if (!get_num (&cp, &domain_id, 0, 256))
						usage ();
					break;
#ifdef DDS_DEBUG
				case 's':
					shell = 1;
					break;
#endif
				case 'v':
					trace = 1;
					if (*cp == 'v') {
						verbose = 1;
						cp++;
					}
					break;
				case 'h':
					help = 1;
				default:
					if (!help)
						fprintf (stderr, "Unknown option!\r\n");
					usage ();
				break;
			}
		}
	}
	return (i);
}

DDS_ReturnCode_t access_db_dump (void) {}
int guid_local_component (GuidPrefix_t *gp) { return (0); }

unsigned char msg [] = {
/*0*/	0x50, 0x00, 0x10, 0x00, 0x57, 0xad, 0xab, 0x8a, 0x80, 0x00, 0x0d, 0x3e, 0x27, 0x3f, 0x00, 0x00,
/*16*/	0x00, 0x00, 0x01, 0xc1, 0x58, 0x00, 0x04, 0x00, 0x3f, 0x0c, 0x00, 0x00, 0x15, 0x00, 0x04, 0x00,
/*32*/	0x02, 0x01, 0x00, 0x00, 0x16, 0x00, 0x04, 0x00, 0x01, 0x1e, 0x00, 0x00, 0x43, 0x00, 0x04, 0x00,
/*48*/	0x00, 0x00, 0x00, 0x00, 0x31, 0x00, 0x18, 0x00, 0x01, 0x00, 0x00, 0x00, 0xf3, 0x99, 0x00, 0x00,
/*64*/	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0a, 0x00, 0x02, 0x0f,
/*80*/	0x31, 0x00, 0x18, 0x00, 0x01, 0x00, 0x00, 0x00, 0xf3, 0x99, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
/*96*/	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xac, 0x14, 0x03, 0x35, 0x48, 0x00, 0x18, 0x00,
/*112*/	0x01, 0x00, 0x00, 0x00, 0xe9, 0x99, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
/*128*/	0x00, 0x00, 0x00, 0x00, 0xef, 0xff, 0x00, 0x01, 0x32, 0x00, 0x18, 0x00, 0x01, 0x00, 0x00, 0x00,
/*144*/	0xf2, 0x99, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
/*160*/	0x0a, 0x00, 0x02, 0x0f, 0x32, 0x00, 0x18, 0x00, 0x01, 0x00, 0x00, 0x00, 0xf2, 0x99, 0x00, 0x00,
/*176*/	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xac, 0x14, 0x03, 0x35,
/*192*/	0x33, 0x00, 0x18, 0x00, 0x01, 0x00, 0x00, 0x00, 0xe8, 0x99, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
/*208*/	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xef, 0xff, 0x00, 0x01, 0x34, 0x00, 0x04, 0x00,
/*224*/	0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x08, 0x00, 0x1e, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
/*240*/	0x62, 0x00, 0x2c, 0x00, 0x28, 0x00, 0x00, 0x00, 0x3c, 0x72, 0x69, 0x64, 0x3a, 0x37, 0x66, 0x30,
/*256*/	0x66, 0x31, 0x36, 0x63, 0x32, 0x31, 0x34, 0x63, 0x36, 0x65, 0x64, 0x38, 0x35, 0x3e, 0x3c, 0x64,
/*272*/	0x69, 0x64, 0x3a, 0x33, 0x61, 0x65, 0x3e, 0x3c, 0x75, 0x69, 0x64, 0x3a, 0x39, 0x34, 0x3e, 0x00,
/*288*/	0x00, 0x80, 0x04, 0x00, 0x00, 0x00, 0x03, 0x02, 0x01, 0x80, 0x04, 0x00, 0x01, 0x00, 0x00, 0x00,
/*304*/	0x02, 0x80, 0x04, 0x00, 0x01, 0x00, 0x01, 0x00, 0x03, 0x80, 0x1c, 0x00, 0x01, 0x00, 0x00, 0x00,
/*320*/	0x01, 0x00, 0x00, 0x00, 0xfc, 0x11, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
/*336*/	0x00, 0x00, 0x00, 0x00, 0x0a, 0x00, 0x02, 0x0f, 0x03, 0x80, 0x1c, 0x00, 0x01, 0x00, 0x00, 0x00,
/*352*/	0x01, 0x00, 0x00, 0x00, 0xfc, 0x11, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
/*368*/	0x00, 0x00, 0x00, 0x00, 0xac, 0x14, 0x03, 0x35, 0x05, 0x80, 0x2c, 0x00, 0x27, 0x00, 0x00, 0x00,
/*384*/	0x3c, 0x72, 0x69, 0x64, 0x3a, 0x37, 0x66, 0x30, 0x66, 0x31, 0x36, 0x63, 0x32, 0x31, 0x34, 0x63,
/*400*/	0x36, 0x65, 0x64, 0x38, 0x35, 0x3e, 0x3c, 0x64, 0x69, 0x64, 0x3a, 0x33, 0x61, 0x65, 0x3e, 0x3c,
/*416*/	0x75, 0x69, 0x64, 0x3a, 0x39, 0x34, 0x3e, 0x00, 0x06, 0x80, 0x14, 0x00, 0x10, 0x00, 0x00, 0x00,
/*432*/	0x99, 0xdc, 0xca, 0xd0, 0x5a, 0x87, 0x35, 0x41, 0x07, 0x47, 0xfd, 0x4c, 0xf8, 0x24, 0x26, 0x25,
/*448*/	0x01, 0x00, 0x00, 0x00
};

int test_part_pid (void)
{
	DBW				dbw;
	ssize_t				s;
	SPDPdiscoveredParticipantData	disc;
	PIDSet_t			pids;

	dbw.dbp = NULL;
	dbw.data = msg;
	dbw.left = sizeof (msg) + 12;
	dbw.length = sizeof (msg);
	s = pid_parse_participant_data (&dbw, &disc, &pids, 0);
	if (s < 0)
		printf ("Error returned: %d\r\n", s);
	else if (!disc.identity || !disc.permissions)
		printf ("Parse ok, but no identity/permissions found!\r\n");
	else
		printf ("Parse ok: identity=%p, permissions=%p\r\n", (void *) disc.identity, (void *) disc.permissions);
	return (s);
}

void run_all (void)
{
	test_part_pid ();
}

int main (int argc, const char *argv [])
{
	DDS_DomainParticipant		part;
	int				n;
	DDS_ReturnCode_t		error;

	n = do_switches (argc, argv);
#ifdef DDS_DEBUG
	if (shell)
		DDS_Debug_start ();
#endif
	DDS_entity_name ("Technicolor PID Test Program");
	DDS_RTPS_control (!no_rtps);

	/* Create a domain participant. */
	part = DDS_DomainParticipantFactory_create_participant (domain_id, NULL, NULL, 0);
	if (!part) {
		printf ("DDS_DomainParticipantFactory_create_participant () failed!");
		return (1);
	}
	run_all ();
	error = DDS_DomainParticipantFactory_delete_participant (part);

	return (0);
}

